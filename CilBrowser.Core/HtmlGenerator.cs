/* CIL Browser (https://github.com/MSDN-WhiteKnight/CilBrowser)
 * Copyright (c) 2022,  MSDN.WhiteKnight 
 * License: BSD 3-Clause */
using System;
using System.Collections.Generic;
using System.IO;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using CilTools.BytecodeAnalysis;
using CilTools.Syntax;

namespace CilBrowser.Core
{
    public class HtmlGenerator
    {
        Assembly _ass; //could be null when unknown

        const string Footer = "Generated by <a href=\"https://github.com/MSDN-WhiteKnight/CilBrowser\">CIL Browser</a>";

        public HtmlGenerator()
        {
            this._ass = null;
        }

        public HtmlGenerator(Assembly ass)
        {
            this._ass = ass;
        }

        static bool IsTypeInAssembly(Type t, Assembly ass)
        {
            if (t == null || ass == null) return false;

            Assembly typeAssembly = t.Assembly;

            if (typeAssembly == null) return false;

            string name1 = typeAssembly.GetName().Name;
            string name2 = ass.GetName().Name;
            return string.Equals(name1, name2, StringComparison.InvariantCultureIgnoreCase);
        }

        static bool IsMethodInAssembly(MethodBase mb, Assembly ass)
        {
            if (mb == null || ass == null) return false;

            Type tDecl = mb.DeclaringType;

            return IsTypeInAssembly(tDecl, ass);
        }

        void VisualizeNode(SyntaxNode node, HtmlBuilder target)
        {
            SyntaxNode[] children = node.GetChildNodes();
            HtmlAttribute[] attrs;

            if (children.Length > 0)
            {
                foreach (SyntaxNode child in children) VisualizeNode(child, target);
            }
            else if (node is KeywordSyntax)
            {
                KeywordSyntax ks = (KeywordSyntax)node;

                if (ks.Kind == KeywordKind.DirectiveName)
                {
                    attrs = new HtmlAttribute[1];
                    attrs[0] = new HtmlAttribute("style", "color: magenta;");
                }
                else if (ks.Kind == KeywordKind.Other)
                {
                    attrs = new HtmlAttribute[1];
                    attrs[0] = new HtmlAttribute("style", "color: blue;");
                }
                else attrs = new HtmlAttribute[0];

                target.WriteTag("span", node.ToString(), attrs);
            }
            else if (node is IdentifierSyntax)
            {
                IdentifierSyntax ids = (IdentifierSyntax)node;
                string tagName;
                const string spanStyleID = "color: rgb(43, 145, 175); text-decoration: none; ";
                List<HtmlAttribute> attrList = new List<HtmlAttribute>(5);

                if (ids.IsMemberName)
                {
                    if (ids.TargetMember is Type)
                    {
                        Type targetType = (Type)ids.TargetMember;

                        if (IsTypeInAssembly(targetType, this._ass))
                        {
                            //hyperlink for types in the same assembly
                            tagName = "a";
                            attrList.Add(new HtmlAttribute("href", GenerateTypeFileName(targetType)));
                        }
                        else
                        {
                            //plaintext name for other types
                            tagName = "span";                            
                        }
                    }
                    else if (ids.TargetMember is MethodBase)
                    {
                        MethodBase mb = (MethodBase)ids.TargetMember;

                        if (node.Parent is DirectiveSyntax && 
                            Utils.StrEquals(((DirectiveSyntax)node.Parent).Name, "method"))
                        {
                            //anchor when in method signature
                            tagName = "a";
                            attrList.Add(new HtmlAttribute("name", GenerateMethodAnchor(mb)));
                            attrList.Add(new HtmlAttribute("href", GenerateMethodURL(mb)));
                        }
                        else if (IsMethodInAssembly(mb, this._ass))
                        {
                            //hyperlink for methods in the same assembly
                            tagName = "a";
                            attrList.Add(new HtmlAttribute("href", GenerateMethodURL(mb)));
                        }
                        else
                        {
                            //plaintext name for other methods
                            tagName = "span";
                        }
                    }
                    else tagName = "span";

                    attrList.Add(new HtmlAttribute("style", spanStyleID));
                }
                else tagName = "span";
                
                target.WriteTag(tagName, node.ToString(), attrList.ToArray());
            }
            else if (node is LiteralSyntax)
            {
                LiteralSyntax ls = (LiteralSyntax)node;

                if (ls.Value is string)
                {
                    attrs = new HtmlAttribute[1];
                    attrs[0] = new HtmlAttribute("style", "color: red;");
                }
                else attrs = new HtmlAttribute[0];

                target.WriteTag("span", node.ToString(), attrs);
            }
            else if (node is CommentSyntax)
            {
                attrs = new HtmlAttribute[1];
                attrs[0] = new HtmlAttribute("style", "color: green;");
                target.WriteTag("span", node.ToString(), attrs);
            }
            else
            {
                target.WriteEscaped(node.ToString());
            }
        }

        void WriteHeaderHTML(HtmlBuilder target)
        {
            target.StartParagraph();
            target.WriteEscaped(".NET CIL Browser");

            if (this._ass != null)
            {
                target.WriteRaw("&nbsp;-&nbsp;");
                target.WriteHyperlink("index.html", this._ass.GetName().Name);
            }

            target.EndParagraph();
        }

        public string VisualizeSyntaxNodes(IEnumerable<SyntaxNode> nodes, string title, string navigation)
        {
            StringBuilder sb = new StringBuilder(5000);
            HtmlBuilder html = new HtmlBuilder(sb);
            html.StartDocument(title);
            this.WriteHeaderHTML(html);
            html.WriteTag("h2", title);
            html.WriteTagStart("table", new HtmlAttribute[] { 
                new HtmlAttribute("width", "100%"), new HtmlAttribute("cellpadding", "5")
            });
            html.WriteTagStart("tr");

            //navigation
            if (!string.IsNullOrEmpty(navigation))
            {
                html.WriteTagStart("td", new HtmlAttribute[] { 
                    new HtmlAttribute("width", "200"), new HtmlAttribute("valign", "top")
                });

                html.WriteRaw(navigation);
                html.WriteTagEnd("td");
            }

            //content
            html.WriteTagStart("td", HtmlBuilder.OneAttribute("valign", "top"));
            html.WriteTagStart("pre", HtmlBuilder.OneAttribute("style", "white-space: pre-wrap;"));
            html.WriteTagStart("code");

            foreach (SyntaxNode node in nodes) VisualizeNode(node, html);

            html.WriteTagEnd("code");
            html.WriteTagEnd("pre");
            html.WriteTagEnd("td");
            html.WriteTagEnd("tr");
            html.WriteTagEnd("table");

            html.StartParagraph();            
            html.WriteHyperlink("index.html", "Back to table of contents");
            html.EndParagraph();

            WriteFooter(html);
            html.EndDocument();
            return sb.ToString();
        }

        public static string VisualizeMethod(MethodBase mb)
        {
            CilGraph gr = CilGraph.Create(mb);
            SyntaxNode[] nodes = new SyntaxNode[] { gr.ToSyntaxTree() };
            HtmlGenerator html = new HtmlGenerator();
            return html.VisualizeSyntaxNodes(nodes, "Method: " + mb.Name, string.Empty);
        }

        static string VisualizeNavigationPanel(Type t)
        {
            StringBuilder sb = new StringBuilder(1000);
            HtmlBuilder html = new HtmlBuilder(sb);
            Assembly ass = t.Assembly;

            if (ass == null) return string.Empty;

            Type[] types = ass.GetTypes();

            for (int i = 0; i < types.Length; i++)
            {
                if (!Utils.StrEquals(types[i].Namespace, t.Namespace)) continue;

                html.StartParagraph();

                if (Utils.StrEquals(types[i].FullName, t.FullName))
                {
                    html.WriteEscaped(types[i].Name);
                }
                else
                {
                    html.WriteHyperlink(GenerateTypeFileName(types[i]), types[i].Name);
                }

                html.EndParagraph();
            }

            return sb.ToString();
        }

        public string VisualizeType(Type t)
        {
            SyntaxNode[] nodes = SyntaxNode.GetTypeDefSyntax(t, true, new DisassemblerParams()).ToArray();

            if (nodes.Length == 0) return string.Empty;

            if (nodes.Length == 1)
            {
                if (string.IsNullOrWhiteSpace(nodes[0].ToString())) return string.Empty;
            }

            return VisualizeSyntaxNodes(nodes, "Type: " + t.Name, VisualizeNavigationPanel(t));
        }

        public string VisualizeAssemblyManifest(Assembly ass)
        {
            IEnumerable<SyntaxNode> nodes = Disassembler.GetAssemblyManifestSyntaxNodes(ass);
            return VisualizeSyntaxNodes(nodes, "Assembly: " + ass.GetName().Name, string.Empty);
        }

        static string GenerateTypeFileName(Type t)
        {
            return ((uint)t.MetadataToken).ToString("X", CultureInfo.InvariantCulture) + ".html";
        }

        static string GenerateMethodAnchor(MethodBase mb)
        {
            return "M"+((uint)mb.MetadataToken).ToString("X", CultureInfo.InvariantCulture);
        }

        static string GenerateMethodURL(MethodBase mb)
        {
            if (mb.DeclaringType == null) return string.Empty;

            return GenerateTypeFileName(mb.DeclaringType) + "#" + GenerateMethodAnchor(mb);
        }

        static int CompareTypes(Type x, Type y)
        {
            string s1 = x.FullName;
            string s2 = y.FullName;
            return string.Compare(s1, s2, StringComparison.OrdinalIgnoreCase);
        }

        static void WriteFooter(HtmlBuilder target)
        {
            target.WriteTag("hr", string.Empty);
            target.StartParagraph();
            target.WriteRaw(Footer);
            target.EndParagraph();
        }

        static Dictionary<string, List<Type>> GroupByNamespace(Type[] types)
        {
            Dictionary<string, List<Type>> ret = new Dictionary<string, List<Type>>();

            for (int i = 0; i < types.Length; i++)
            {
                string ns = types[i].Namespace;

                if (ns == null) ns = string.Empty;

                List<Type> list;

                if (ret.ContainsKey(ns))
                {
                    list = ret[ns];
                }
                else
                {
                    list = new List<Type>();
                    ret[ns] = list;
                }

                list.Add(types[i]);
            }

            return ret;
        }

        /// <summary>
        /// Generates a static website that contains disassembled CIL for the specified assembly
        /// </summary>
        public static void GenerateWebsite(Assembly ass)
        {
            HtmlGenerator generator = new HtmlGenerator(ass);

            //write assembly manifest
            string html = generator.VisualizeAssemblyManifest(ass);
            File.WriteAllText("assembly.html", html);
            
            //create Table of contents builder
            StringBuilder sb = new StringBuilder(1000);
            HtmlBuilder toc = new HtmlBuilder(sb);
            AssemblyName an = ass.GetName();
            Console.WriteLine("Generating website for " + an.Name);
            toc.StartDocument(".NET CIL Browser - " + an.Name);
            toc.WriteParagraph(".NET CIL Browser");
            toc.WriteTag("h1", an.Name);
            toc.StartParagraph();
            toc.WriteHyperlink("assembly.html", "(Assembly manifest)");
            toc.EndParagraph();

            //write types
            Type[] types = ass.GetTypes();
            Dictionary<string, List<Type>> typeMap = GroupByNamespace(types);
            string[] namespaces = typeMap.Keys.ToArray();
            Array.Sort(namespaces);

            for (int i = 0; i < namespaces.Length; i++)
            {
                string nsText = namespaces[i];
                List<Type> nsTypes = typeMap[namespaces[i]];

                if (nsTypes.Count == 0) continue;

                if (nsTypes.Count == 1)
                {
                    BindingFlags all = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | 
                        BindingFlags.NonPublic;

                    if (Utils.StrEquals(nsTypes[0].FullName, "<Module>") &&
                        nsTypes[0].GetFields(all).Length == 0 && nsTypes[0].GetMethods(all).Length == 0)
                    {
                        continue; //ignore namespace consisting only from empty <Module> type
                    }
                }

                if (string.IsNullOrEmpty(nsText)) nsText = "(No namespace)";
                else nsText = nsText + " namespace";

                toc.WriteTag("h2", nsText);
                nsTypes.Sort(CompareTypes);

                for (int j = 0; j < nsTypes.Count; j++)
                {
                    //file content
                    html = generator.VisualizeType(nsTypes[j]);
                    string fname = GenerateTypeFileName(nsTypes[j]);

                    if (!string.IsNullOrWhiteSpace(html))
                    {
                        Console.WriteLine(nsTypes[j].FullName);

                        //TOC entry
                        toc.StartParagraph();
                        toc.WriteHyperlink(fname, nsTypes[j].FullName);
                        toc.EndParagraph();
                    }
                    else
                    {
                        Console.WriteLine(nsTypes[j].FullName + " - empty");
                    }
                    
                    File.WriteAllText(fname, html);        
                }
            }
            
            //write TOC
            WriteFooter(toc);
            toc.EndDocument();
            File.WriteAllText("index.html", sb.ToString());
        }
    }
}
