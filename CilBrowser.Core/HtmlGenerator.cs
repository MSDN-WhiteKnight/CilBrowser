/* CIL Browser (https://github.com/MSDN-WhiteKnight/CilBrowser)
 * Copyright (c) 2022,  MSDN.WhiteKnight 
 * License: BSD 3-Clause */
using System;
using System.Collections.Generic;
using System.IO;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using CilTools.BytecodeAnalysis;
using CilTools.Syntax;

namespace CilBrowser.Core
{
    public class HtmlGenerator
    {
        Assembly _ass; //could be null when unknown

        const string Footer = "Generated by <a href=\"https://github.com/MSDN-WhiteKnight/CilBrowser\">CIL Browser</a>";

        public HtmlGenerator()
        {
            this._ass = null;
        }

        public HtmlGenerator(Assembly ass)
        {
            this._ass = ass;
        }

        static bool IsTypeInAssembly(Type t, Assembly ass)
        {
            if (t == null || ass == null) return false;

            Assembly typeAssembly = t.Assembly;

            if (typeAssembly == null) return false;

            string name1 = typeAssembly.GetName().Name;
            string name2 = ass.GetName().Name;
            return string.Equals(name1, name2, StringComparison.InvariantCultureIgnoreCase);
        }

        static bool IsMethodInAssembly(MethodBase mb, Assembly ass)
        {
            if (mb == null || ass == null) return false;

            Type tDecl = mb.DeclaringType;

            return IsTypeInAssembly(tDecl, ass);
        }

        void VisualizeNode(SyntaxNode node, HtmlBuilder target)
        {
            SyntaxNode[] children = node.GetChildNodes();
            HtmlAttribute[] attrs;

            if (children.Length > 0)
            {
                foreach (SyntaxNode child in children) VisualizeNode(child, target);
            }
            else if (node is KeywordSyntax)
            {
                KeywordSyntax ks = (KeywordSyntax)node;

                if (ks.Kind == KeywordKind.DirectiveName)
                {
                    attrs = new HtmlAttribute[1];
                    attrs[0] = new HtmlAttribute("style", "color: magenta;");
                }
                else if (ks.Kind == KeywordKind.Other)
                {
                    attrs = new HtmlAttribute[1];
                    attrs[0] = new HtmlAttribute("style", "color: blue;");
                }
                else attrs = new HtmlAttribute[0];

                target.WriteTag("span", node.ToString(), attrs);
            }
            else if (node is IdentifierSyntax)
            {
                IdentifierSyntax ids = (IdentifierSyntax)node;
                string tagName;
                const string spanStyleID = "color: rgb(43, 145, 175); text-decoration: none; ";
                List<HtmlAttribute> attrList = new List<HtmlAttribute>(5);

                if (ids.IsMemberName)
                {
                    if (ids.TargetMember is Type)
                    {
                        Type targetType = (Type)ids.TargetMember;

                        if (IsTypeInAssembly(targetType, this._ass))
                        {
                            //hyperlink for types in the same assembly
                            tagName = "a";
                            attrList.Add(new HtmlAttribute("href", GenerateTypeFileName(targetType)));
                        }
                        else
                        {
                            //plaintext name for other types
                            tagName = "span";                            
                        }
                    }
                    else if (ids.TargetMember is MethodBase)
                    {
                        MethodBase mb = (MethodBase)ids.TargetMember;

                        if (node.Parent is DirectiveSyntax && 
                            Utils.StrEquals(((DirectiveSyntax)node.Parent).Name, "method"))
                        {
                            //anchor when in method signature
                            tagName = "a";
                            attrList.Add(new HtmlAttribute("name", GenerateMethodAnchor(mb)));
                            attrList.Add(new HtmlAttribute("href", GenerateMethodURL(mb)));
                        }
                        else if (IsMethodInAssembly(mb, this._ass))
                        {
                            //hyperlink for methods in the same assembly
                            tagName = "a";
                            attrList.Add(new HtmlAttribute("href", GenerateMethodURL(mb)));
                        }
                        else
                        {
                            //plaintext name for other methods
                            tagName = "span";
                        }
                    }
                    else tagName = "span";
                }
                else tagName = "span";
                
                attrList.Add(new HtmlAttribute("style", spanStyleID));
                target.WriteTag(tagName, node.ToString(), attrList.ToArray());
            }
            else if (node is LiteralSyntax)
            {
                LiteralSyntax ls = (LiteralSyntax)node;

                if (ls.Value is string)
                {
                    attrs = new HtmlAttribute[1];
                    attrs[0] = new HtmlAttribute("style", "color: red;");
                }
                else attrs = new HtmlAttribute[0];

                target.WriteTag("span", node.ToString(), attrs);
            }
            else if (node is CommentSyntax)
            {
                attrs = new HtmlAttribute[1];
                attrs[0] = new HtmlAttribute("style", "color: green;");
                target.WriteTag("span", node.ToString(), attrs);
            }
            else
            {
                target.WriteEscaped(node.ToString());
            }
        }

        void WriteHeaderHTML(HtmlBuilder target)
        {
            target.StartParagraph();
            target.WriteEscaped(".NET CIL Browser");

            if (this._ass != null)
            {
                target.WriteRaw("&nbsp;-&nbsp;");
                target.WriteHyperlink("index.html", this._ass.GetName().Name);
            }

            target.EndParagraph();
        }

        public string VisualizeSyntaxNodes(IEnumerable<SyntaxNode> nodes, string title)
        {
            StringBuilder sb = new StringBuilder(5000);
            HtmlBuilder html = new HtmlBuilder(sb);
            html.StartDocument(title);
            this.WriteHeaderHTML(html);
            html.WriteTag("h2", title);
            html.WriteTagStart("pre");
            html.WriteTagStart("code");

            foreach (SyntaxNode node in nodes) VisualizeNode(node, html);

            html.WriteTagEnd("code");
            html.WriteTagEnd("pre");
            html.StartParagraph();            
            html.WriteHyperlink("index.html", "Back to table of contents");
            html.EndParagraph();

            WriteFooter(html);
            html.EndDocument();
            return sb.ToString();
        }

        public static string VisualizeMethod(MethodBase mb)
        {
            CilGraph gr = CilGraph.Create(mb);
            SyntaxNode[] nodes = new SyntaxNode[] { gr.ToSyntaxTree() };
            HtmlGenerator html = new HtmlGenerator();
            return html.VisualizeSyntaxNodes(nodes, "Method: " + mb.Name);
        }

        public string VisualizeType(Type t)
        {
            SyntaxNode[] nodes = SyntaxNode.GetTypeDefSyntax(t, true, new DisassemblerParams()).ToArray();

            if (nodes.Length == 0) return string.Empty;

            if (nodes.Length == 1)
            {
                if (string.IsNullOrWhiteSpace(nodes[0].ToString())) return string.Empty;
            }

            return VisualizeSyntaxNodes(nodes, "Type: " + t.Name);
        }

        public string VisualizeAssemblyManifest(Assembly ass)
        {
            IEnumerable<SyntaxNode> nodes = Disassembler.GetAssemblyManifestSyntaxNodes(ass);
            return VisualizeSyntaxNodes(nodes, "Assembly: " + ass.GetName().Name);
        }

        static string GenerateTypeFileName(Type t)
        {
            return ((uint)t.MetadataToken).ToString("X", CultureInfo.InvariantCulture) + ".html";
        }

        static string GenerateMethodAnchor(MethodBase mb)
        {
            return "M"+((uint)mb.MetadataToken).ToString("X", CultureInfo.InvariantCulture);
        }

        static string GenerateMethodURL(MethodBase mb)
        {
            if (mb.DeclaringType == null) return string.Empty;

            return GenerateTypeFileName(mb.DeclaringType) + "#" + GenerateMethodAnchor(mb);
        }

        static int CompareTypes(Type x, Type y)
        {
            string s1 = x.FullName;
            string s2 = y.FullName;
            return string.Compare(s1, s2, StringComparison.OrdinalIgnoreCase);
        }

        static void WriteFooter(HtmlBuilder target)
        {
            target.WriteTag("hr", string.Empty);
            target.StartParagraph();
            target.WriteRaw(Footer);
            target.EndParagraph();
        }

        /// <summary>
        /// Generates a static website that contains disassembled CIL for the specified assembly
        /// </summary>
        public static void GenerateWebsite(Assembly ass)
        {
            HtmlGenerator generator = new HtmlGenerator(ass);

            //write assembly manifest
            string html = generator.VisualizeAssemblyManifest(ass);
            File.WriteAllText("assembly.html", html);
            
            //create Table of contents builder
            StringBuilder sb = new StringBuilder(1000);
            HtmlBuilder toc = new HtmlBuilder(sb);
            AssemblyName an = ass.GetName();
            Console.WriteLine("Generating website for " + an.Name);
            toc.StartDocument(".NET CIL Browser - " + an.Name);
            toc.WriteParagraph(".NET CIL Browser");
            toc.WriteTag("h1", an.Name);
            toc.StartParagraph();
            toc.WriteHyperlink("assembly.html", "(Assembly manifest)");
            toc.EndParagraph();

            //write types
            Type[] types = ass.GetTypes();
            Array.Sort(types, CompareTypes);

            for (int i = 0; i < types.Length; i++)
            {
                //file content
                html = generator.VisualizeType(types[i]);

                if (string.IsNullOrWhiteSpace(html))
                {
                    Console.WriteLine(types[i].FullName + " - skipped");
                    continue;
                }

                Console.WriteLine(types[i].FullName);
                string fname = GenerateTypeFileName(types[i]);
                File.WriteAllText(fname, html);

                //TOC entry
                toc.StartParagraph();
                toc.WriteHyperlink(fname, types[i].FullName);
                toc.EndParagraph();
            }

            //write TOC
            WriteFooter(toc);
            toc.EndDocument();
            File.WriteAllText("index.html", sb.ToString());
        }
    }
}
